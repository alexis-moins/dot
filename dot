#!/usr/bin/env bash
# This script was generated by bashly 1.1.8 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

version_command() {
  echo "$version"
}

dot_usage() {
  if [[ -n $long_usage ]]; then
    printf "dot - dotfiles manager based on stow\n"
    echo

  else
    printf "dot - dotfiles manager based on stow\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dot COMMAND\n"
  printf "  dot [COMMAND] --help | -h\n"
  printf "  dot --version | -v\n"
  echo

  printf "%s\n" "Commands:"
  printf "  %s   Show help about a command\n" "help  "
  printf "  %s   Create a link to the dot script\n" "link  "
  printf "  %s   Remove the link to the dot script\n" "unlink"
  printf "  %s   Update to the latest version\n" "update"
  printf "  %s   Show environment information\n" "env   "
  echo
  printf "%s\n" "Dotfiles Commands:"
  printf "  %s   Clone a remote git dotfiles repository\n" "clone "
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    printf "%s\n" "Environment Variables:"

    printf "  %s\n" "DOT_INSTALL_DIR"
    printf "    Directory where the repository was cloned\n"
    printf "    Default: ${HOME}/.dot\n"
    echo

    printf "  %s\n" "DOT_DOTFILES_DIR"
    printf "    Directory where the projects will be managed\n"
    printf "    Default: ${HOME}/dotfiles\n"
    echo

  fi
}

dot_help_usage() {
  if [[ -n $long_usage ]]; then
    printf "dot help - Show help about a command\n"
    echo

  else
    printf "dot help - Show help about a command\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dot help [COMMAND]\n"
  printf "  dot help --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "COMMAND"
    printf "    Help subject\n"
    echo

  fi
}

dot_clone_usage() {
  if [[ -n $long_usage ]]; then
    printf "dot clone - Clone a remote git dotfiles repository\n"
    echo

  else
    printf "dot clone - Clone a remote git dotfiles repository\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dot clone REPOSITORY\n"
  printf "  dot clone --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "REPOSITORY"
    printf "    Remote repository to clone (FORMAT: <username>/<repository>)\n"
    echo

    printf "%s\n" "Examples:"
    printf "  dot clone alexis-moins/dotfiles\n"
    echo

  fi
}

dot_link_usage() {
  if [[ -n $long_usage ]]; then
    printf "dot link - Create a link to the dot script\n"
    echo

  else
    printf "dot link - Create a link to the dot script\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dot link [PATH] [OPTIONS]\n"
  printf "  dot link --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--copy, -c"
    printf "    Copy the script instead of creating a symbolic link\n"
    echo

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "PATH"
    printf "    Path to the link\n"
    printf "    Default: ${HOME}/.local/bin\n"
    echo

    printf "%s\n" "Examples:"
    printf "  dot link -c\n"
    printf "  dot link /usr/bin\n"
    echo

  fi
}

dot_unlink_usage() {
  if [[ -n $long_usage ]]; then
    printf "dot unlink - Remove the link to the dot script\n"
    echo

  else
    printf "dot unlink - Remove the link to the dot script\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dot unlink [PATH]\n"
  printf "  dot unlink --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Arguments:"

    printf "  %s\n" "PATH"
    printf "    Path to the link\n"
    printf "    Default: ${HOME}/.local/bin\n"
    echo

    printf "%s\n" "Examples:"
    printf "  dot unlink\n"
    echo

  fi
}

dot_update_usage() {
  if [[ -n $long_usage ]]; then
    printf "dot update - Update to the latest version\n"
    echo

  else
    printf "dot update - Update to the latest version\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dot update\n"
  printf "  dot update --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Examples:"
    printf "  dot update\n"
    echo

  fi
}

dot_env_usage() {
  if [[ -n $long_usage ]]; then
    printf "dot env - Show environment information\n"
    echo

  else
    printf "dot env - Show environment information\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  dot env\n"
  printf "  dot env --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    printf "%s\n" "Examples:"
    printf "  dot env\n"
    echo

  fi
}

normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}

print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

error() {
    gum log --level="error" --prefix="pm" --prefix.foreground="7" --level.foreground="1" "${1}"
}

info() {
    gum log --level="error" --prefix="pm" --prefix.foreground="7" --level.foreground="4" "${1}"
}

warn() {
    gum log --level="warn" --prefix="pm" --prefix.foreground="7" --level.foreground="3" "${1}"
}

dot_help_command() {
  command="${args[command]:-}"
  long_usage=yes

  if [[ -z "$command" ]]; then
    # No command argument, show the global help
    help_function=dot_usage
  else
    # Show the help for the requested command
    help_function="dot_${command}_usage"
  fi

  # Call the help function if it exists
  if [[ $(type -t "$help_function") ]]; then
    "$help_function"
  else
    echo "No help available for this command"
    exit 1
  fi

}

dot_clone_command() {
  local repository="${args[repository]}"

  if [[ -d "${DOT_DOTFILES_DIR}" ]]; then
      error "${DOT_DOTFILES_DIR} is not empty."
      error "Remove it manually if it was intentional."
      exit 1
  fi

  command git clone "git@github.com:${repository}.git" "${DOT_DOTFILES_DIR}"
  info "cloned dotfiles."

}

dot_link_command() {
  local path="${args[path]}"
  local copy="${args[--copy]}"

  local source="${DOT_INSTALL_DIR}"

  if [[ -f "${path}/dot" ]]; then
      error "there is already a link in ${path}."
      exit 1
  fi

  if [[ ! -d "${source}" ]]; then
      error "source directory ${source} does not exist."
      exit 1
  fi

  if [[ ! -f "${source}/dot" ]]; then
      error "script 'dot' not found in ${source}."
      exit 1
  fi

  local executable=`test -n "${copy}" && echo "cp" || echo "ln -s"`

  command ${executable} "${source}/dot" "${path}/dot"
  info "link created in ${path}."

}

dot_unlink_command() {
  local path="${args[path]}"

  if [[ -f "${path}/dot" ]]; then
      run_silent rm "${path}/dot"

      info "link removed from ${path}."
  else
      error "no link found in ${path}."
      exit 1
  fi

}

dot_update_command() {
  if [[ ! -d "${DOT_INSTALL_DIR}" ]]; then
      warn "no dot install directory."
      warn "check documentation for installation instruction."
      exit 1
  fi

  git -C "${DOT_INSTALL_DIR}" pull

}

dot_env_command() {
  echo "DOT_INSTALL_DIR=${DOT_INSTALL_DIR}"
  echo "DOT_DOTFILES_DIR=${DOT_DOTFILES_DIR}"

}

parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        dot_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  export DOT_INSTALL_DIR="${DOT_INSTALL_DIR:-${HOME}/.dot}"
  export DOT_DOTFILES_DIR="${DOT_DOTFILES_DIR:-${HOME}/dotfiles}"

  env_var_names+=("DOT_INSTALL_DIR")
  env_var_names+=("DOT_DOTFILES_DIR")

  if command -v git >/dev/null 2>&1; then
    deps['git']="$(command -v git | head -n1)"
  else
    printf "missing dependency: git\n" >&2
    exit 1
  fi

  if command -v fd >/dev/null 2>&1; then
    deps['fd']="$(command -v fd | head -n1)"
  else
    printf "missing dependency: fd\n" >&2
    exit 1
  fi

  if command -v gum >/dev/null 2>&1; then
    deps['gum']="$(command -v gum | head -n1)"
  else
    printf "missing dependency: gum\n" >&2
    exit 1
  fi

  if command -v rg >/dev/null 2>&1; then
    deps['rg']="$(command -v rg | head -n1)"
  else
    printf "missing dependency: rg\n" >&2
    exit 1
  fi

  action=${1:-}

  case $action in
    -*) ;;

    help)
      action="help"
      shift
      dot_help_parse_requirements "$@"
      shift $#
      ;;

    clone)
      action="clone"
      shift
      dot_clone_parse_requirements "$@"
      shift $#
      ;;

    link)
      action="link"
      shift
      dot_link_parse_requirements "$@"
      shift $#
      ;;

    unlink)
      action="unlink"
      shift
      dot_unlink_parse_requirements "$@"
      shift $#
      ;;

    update)
      action="update"
      shift
      dot_update_parse_requirements "$@"
      shift $#
      ;;

    env)
      action="env"
      shift
      dot_env_parse_requirements "$@"
      shift $#
      ;;

    "")
      dot_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

dot_help_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dot_help_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="help"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['command']+x} ]]; then
          args['command']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

dot_clone_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dot_clone_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="clone"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['repository']+x} ]]; then
          args['repository']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  if [[ -z ${args['repository']+x} ]]; then
    printf "missing required argument: REPOSITORY\nusage: dot clone REPOSITORY\n" >&2
    exit 1
  fi

}

dot_link_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dot_link_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="link"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --copy | -c)

        args['--copy']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['path']+x} ]]; then
          args['path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  [[ -n ${args['path']:-} ]] || args['path']="${HOME}/.local/bin"

}

dot_unlink_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dot_unlink_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="unlink"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        if [[ -z ${args['path']+x} ]]; then
          args['path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  [[ -n ${args['path']:-} ]] || args['path']="${HOME}/.local/bin"

}

dot_update_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dot_update_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="update"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

dot_env_parse_requirements() {

  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dot_env_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  action="env"

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)

        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

initialize() {
  version="0.1.0"
  long_usage=''
  set -e

  export DOT_INSTALL_DIR="${DOT_INSTALL_DIR:-${HOME}/.dot}"
  export DOT_DOTFILES_DIR="${DOT_DOTFILES_DIR:-${HOME}/dotfiles}"

}

run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a env_var_names=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "help") dot_help_command ;;
    "clone") dot_clone_command ;;
    "link") dot_link_command ;;
    "unlink") dot_unlink_command ;;
    "update") dot_update_command ;;
    "env") dot_env_command ;;
  esac
}

initialize
run "$@"
